<script>
// === Versão ProCode-2025: feedback adaptativo e sequência contínua ===
const canvas=document.getElementById('canvas');
const ctx=canvas.getContext('2d');
const overlay=document.getElementById('overlay');
const octx=overlay.getContext('2d');
const statusEl=document.getElementById('status');
const patternEl=document.getElementById('pattern');
const confEl=document.getElementById('conf');
const statsEl=document.getElementById('stats');

let video=document.createElement('video'); video.autoplay=true; video.playsInline=true;
let stream=null, running=false;

// Histórico e pesos adaptativos
let sequence=[]; // sequência simulada baseada no gráfico enviado
let weights={player:1, banker:1, tie:1}; 
let acertos=0, erros=0, empates=0;

// === Utilitários ===
function resizeCanvas(w,h){canvas.width=w; canvas.height=h; overlay.width=w; overlay.height=h;}

function colorRole(r,g,b){
  if(r>170&&g<80&&b<80) return "banker";
  if(b>150&&r<80&&g<100) return "player";
  if(r>180&&g>180&&b<140) return "tie";
  return null;
}

// Detecta bolinhas na imagem
function detect(frame,w,h){
  const data=frame.data,step=5;
  const pts=[];
  for(let y=0;y<h;y+=step){
    for(let x=0;x<w;x+=step){
      const i=(y*w+x)*4;
      const role=colorRole(data[i],data[i+1],data[i+2]);
      if(role) pts.push({x,y,role});
    }
  }
  // Clustering simplificado
  const clusters=[], dist=10;
  pts.forEach(p=>{
    let f=clusters.find(c=>Math.hypot(c.x-p.x,c.y-p.y)<dist && c.role===p.role);
    if(f){ f.x=(f.x*f.n+p.x)/(f.n+1); f.y=(f.y*f.n+p.y)/(f.n+1); f.n++; }
    else clusters.push({x:p.x,y:p.y,role:p.role,n:1});
  });
  return clusters;
}

function drawOverlay(blobs){
  octx.clearRect(0,0,overlay.width,overlay.height);
  blobs.forEach(b=>{
    octx.beginPath();
    octx.arc(b.x,b.y,8,0,Math.PI*2);
    octx.strokeStyle=b.role==="player"?"#00ffc3":b.role==="banker"?"#ff3366":"#ffff66";
    octx.lineWidth=2; octx.stroke();
  });
}

// === Análise inteligente adaptativa ===
function analyze(blobs){
  let seq=blobs.map(b=>b.role);
  if(sequence.length>0) seq = sequence.concat(seq); // combina sequência interna
  if(seq.length===0) return {name:"—", conf:0};

  let s=seq.join("");
  let pattern="Padrão neutro", conf=0.5;

  if(/(player){3,}/.test(s)) { pattern="Surf Player"; conf=0.9; }
  else if(/(banker){3,}/.test(s)) { pattern="Surf Banker"; conf=0.9; }
  else if(seq.every((x,i,a)=>i===0||x!==a[i-1])) { pattern="Xadrez"; conf=0.85; }
  else if(seq.includes("tie")) { pattern="Empates frequentes"; conf=0.7; }

  return {name:pattern, conf};
}

// Gera próxima recomendação baseada em pesos e sequência
function nextRecommendation(){
  const keys = Object.keys(weights);
  const sum = keys.reduce((a,k)=>a+weights[k],0);
  let r=Math.random()*sum;
  for(const k of keys){
    if(r<weights[k]) return k;
    r-=weights[k];
  }
  return "player"; // fallback
}

// Atualiza estatísticas visuais
function atualizarStats(){
  const total=acertos+erros+empates;
  const perc=total?Math.round((acertos/total)*100):0;
  statsEl.innerText=`Histórico: ${acertos} acertos / ${erros} erros / ${empates} empates (${perc}%)`;
}

// Feedback adaptativo
function registrar(tipo){
  const rec=nextRecommendation();
  sequence.push(rec); // atualiza "gráfico mental"
  if(tipo==="acerto") { acertos++; weights[rec]*=1.2; }
  if(tipo==="erro") { erros++; weights[rec]*=0.7; Object.keys(weights).forEach(k=>{if(k!==rec) weights[k]*=1.1}); }
  if(tipo==="empate") { empates++; weights.tie*=1.2; }

  // normaliza pesos
  const totalW=weights.player+weights.banker+weights.tie;
  Object.keys(weights).forEach(k=>weights[k]/=totalW);

  atualizarStats();
  const nextRec=nextRecommendation();
  patternEl.innerText=nextRec;
  confEl.innerText=Math.round(weights[nextRec]*100)+"%";
  speak(`Próxima recomendação: ${nextRec}`);
}

// === Loop de análise contínua ===
function runFrame(){
  if(!running) return;
  ctx.drawImage(video,0,0,canvas.width,canvas.height);
  const frame=ctx.getImageData(0,0,canvas.width,canvas.height);
  const blobs=detect(frame,canvas.width,canvas.height);
  drawOverlay(blobs);
  const a=analyze(blobs);
  patternEl.innerText=a.name;
  confEl.innerText=Math.round(a.conf*100)+"%";
  requestAnimationFrame(runFrame);
}

// === Funções de captura ===
async function startCam(){
  try{
    stopAll();
    stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}});
    video.srcObject=stream;
    video.onloadedmetadata=()=>{
      resizeCanvas(video.videoWidth,video.videoHeight);
      running=true;
      statusEl.innerText="Câmera Ativa (Auto)";
      runFrame();
    };
  }catch(e){alert(e);}
}

function stopAll(){ running=false; statusEl.innerText="Parado"; if(stream){stream.getTracks().forEach(t=>t.stop()); stream=null;} octx.clearRect(0,0,overlay.width,overlay.height); }

// Botões
document.getElementById('startCam').onclick=startCam;
document.getElementById('stopBtn').onclick=stopAll;
document.getElementById('btnAcertou').onclick=()=>registrar("acerto");
document.getElementById('btnErrou').onclick=()=>registrar("erro");
document.getElementById('btnEmpate').onclick=()=>registrar("empate");

document.getElementById('sendImg').onclick=()=>{
  const input=document.createElement('input');
  input.type='file';input.accept='image/*';
  input.onchange=e=>{
    const file=e.target.files[0];
    if(!file) return;
    const img=new Image();
    img.onload=()=>{
      resizeCanvas(img.width,img.height);
      ctx.drawImage(img,0,0,canvas.width,canvas.height);
      const frame=ctx.getImageData(0,0,canvas.width,canvas.height);
      const blobs=detect(frame,canvas.width,canvas.height);
      drawOverlay(blobs);
      const a=analyze(blobs);
      patternEl.innerText=a.name;
      confEl.innerText=Math.round(a.conf*100)+"%";
      statusEl.innerText="Imagem analisada";
      sequence=blobs.map(b=>b.role); // inicializa sequência mental
      speak(`Padrão ${a.name}. Confiança ${Math.round(a.conf*100)}%.`);
    };
    img.src=URL.createObjectURL(file);
  };
  input.click();
};
</script>
