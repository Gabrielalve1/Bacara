<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Baccarat Turbo — Robusto (Auto & Manual)</title>
<style>
  :root{--bg:#041021;--panel:#072233;--muted:#9fb4d8;--accent:#ffd36b;--player:#49a9ff;--banker:#ff5a6d;--tie:#c6ffb3}
  *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  body{margin:0;background:linear-gradient(180deg,var(--bg),#01121a);color:#eaf7ff;-webkit-font-smoothing:antialiased}
  .wrap{max-width:920px;margin:14px auto;padding:14px}
  header{display:flex;justify-content:space-between;align-items:center}
  h1{color:var(--accent);margin:0;font-size:20px}
  .panel{background:var(--panel);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);margin-top:12px}
  input,textarea,select,button{font-size:15px}
  input,select{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#eaf7ff}
  textarea{width:100%;min-height:96px;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#eaf7ff;resize:vertical}
  .row{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  .col{flex:1;min-width:140px}
  .btn{padding:10px;border-radius:8px;border:none;background:linear-gradient(180deg,#0f4b5a,#06323f);color:var(--accent);cursor:pointer}
  .small{font-size:13px;color:var(--muted)}
  #rec{margin-top:12px;padding:14px;border-radius:10px;font-weight:900;font-size:20px;text-align:center;background:#ccc;color:#071018;transition:all .12s ease}
  .dot-row{display:flex;gap:6px;flex-wrap:wrap;justify-content:center;margin-top:10px}
  .dot{width:14px;height:14px;border-radius:50%;border:2px solid rgba(255,255,255,0.04)}
  .stats{display:flex;gap:8px;margin-top:10px}
  .stat{flex:1;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;text-align:center}
  .statusBar{margin-top:10px;font-size:13px;color:var(--muted)}
  @media (max-width:420px){ header{flex-direction:column;align-items:flex-start} }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Baccarat Turbo — Robusto (Auto & Manual)</h1>
    <div class="small">Modo: Robust + Watchdog + Backoff</div>
  </header>

  <div class="panel">
    <div class="small">1) Cole o link do gráfico (ou use manual) — se o site exigir login, cole sequência manual.</div>
    <input id="linkInput" placeholder="Cole o link do gráfico aqui (ex: https://...)" />

    <div class="row" style="margin-top:8px">
      <div class="col">
        <div class="small">Proxy (opcional) — ex: https://meu-proxy/fetch?url=</div>
        <input id="proxyInput" placeholder="Opcional: seu proxy (prefixo)"/>
      </div>
      <div class="col">
        <div class="small">CSS selector (opcional) — ex: '#history' ou '.results'</div>
        <input id="selectorInput" placeholder="Opcional: seletor CSS para extrair texto"/>
      </div>
      <div class="col">
        <div class="small">Intervalo auto (ms)</div>
        <select id="intervalSelect">
          <option value="500">500 ms</option>
          <option value="1000" selected>1000 ms</option>
          <option value="2000">2000 ms</option>
          <option value="5000">5000 ms</option>
        </select>
      </div>
    </div>

    <div class="row" style="margin-top:8px">
      <div class="col"><button id="startBtn" class="btn">Iniciar Monitor</button></div>
      <div class="col"><button id="stopBtn" class="btn" disabled>Parar</button></div>
      <div class="col"><button id="forceBtn" class="btn">Forçar Reprocessamento</button></div>
    </div>

    <div style="margin-top:10px" class="small">2) Ou cole manualmente a sequência (P,B,T). Aceita vírgula, espaço, nova linha.</div>
    <textarea id="manualInput" placeholder="Ex: P,B,P,T,B,P (cole se o fetch falhar)"></textarea>

    <div class="row" style="margin-top:8px">
      <div class="col"><button id="analyzeManualBtn" class="btn">Analisar Manual</button></div>
      <div class="col"><button id="appendBtn" class="btn">Adicionar Último</button></div>
      <div class="col"><button id="clearBtn" class="btn">Limpar</button></div>
    </div>

    <div id="rec">—</div>
    <div id="conf" class="small">Confiança: —</div>

    <div class="dot-row" id="dots"></div>

    <div class="stats">
      <div class="stat"><div class="small">Jogador</div><div id="pctP" style="font-weight:800">0%</div></div>
      <div class="stat"><div class="small">Banqueiro</div><div id="pctB" style="font-weight:800">0%</div></div>
      <div class="stat"><div class="small">Empates</div><div id="pctT" style="font-weight:800">0%</div></div>
    </div>

    <div class="statusBar" id="statusBar">Pronto.</div>
  </div>
</div>

<script>
/* Full integrated robust code: watchdog, backoff, safe fetch + parsing + analysis */
const $ = id => document.getElementById(id);

// State
let series = [];
let lastFetchedSnapshot = '';
let monitorRunning = false;
let monitorTimer = null;
let lastTickTs = 0;
let watchdogTimer = null;
let backoffAttempts = 0;

// Config
const MAX_HTML_CHARS = 200000;
const FETCH_TIMEOUT_MS = 3500;
const MAX_RETRIES = 3;
const BACKOFF_BASE = 700;

// Public proxies (include your Vercel proxy first if you want)
const PUBLIC_PROXIES = [
  (u)=>`https://proxy-baccarate-14co.vercel.app/fetch?url=${encodeURIComponent(u)}`,
  (u)=>`https://corsproxy.io/?${encodeURIComponent(u)}`,
  (u)=>`https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`
];

function setStatus(s){ $('statusBar').textContent = s; }
function normalizeToken(tok){
  if(!tok) return null;
  const s = String(tok).trim();
  if(/^(B|BANKER|BANQUEIRO)$/i.test(s)) return 'B';
  if(/^(P|PLAYER|JOGADOR)$/i.test(s)) return 'P';
  if(/^(T|TIE|EMPATE)$/i.test(s)) return 'T';
  if(/^[BP]$/i.test(s)) return s.toUpperCase();
  const m = s.match(/[BPT]/i);
  return m ? m[0].toUpperCase() : null;
}
function parseSequence(text){
  if(!text) return [];
  const cleaned = text.replace(/\r\n/g,',').replace(/[;\/\\|]+/g,',').replace(/\s+/g,',').toUpperCase();
  return cleaned.split(',').map(s=>s.trim()).filter(Boolean).map(normalizeToken).filter(Boolean);
}

// safe fetch with timeout
async function fetchWithTimeout(url, timeout=FETCH_TIMEOUT_MS){
  const controller = new AbortController();
  const id = setTimeout(()=> controller.abort(), timeout);
  try{
    const resp = await fetch(url, { signal: controller.signal, cache:'no-store' });
    clearTimeout(id);
    if(!resp.ok) throw new Error('HTTP ' + resp.status);
    const txt = await resp.text();
    if(txt.length > MAX_HTML_CHARS) throw new Error('HTML very large');
    return txt;
  }catch(e){
    clearTimeout(id);
    throw e;
  }
}

// try proxies sequentially with retries/backoff
async function fetchBest(url, userProxyPrefix){
  const candidates = [];
  if(userProxyPrefix && userProxyPrefix.trim()){
    candidates.push((u)=> userProxyPrefix.trim() + encodeURIComponent(u));
  }
  PUBLIC_PROXIES.forEach(f=> candidates.push(f));
  let lastErr = null;
  for(const build of candidates){
    const tryUrl = build(url);
    for(let attempt=0; attempt<MAX_RETRIES; attempt++){
      try{
        if(!monitorRunning) throw new Error('monitor-stopped');
        const txt = await fetchWithTimeout(tryUrl);
        return { text: txt, used: tryUrl };
      }catch(err){
        lastErr = err;
        const wait = BACKOFF_BASE * Math.pow(2, attempt) + Math.floor(Math.random()*120);
        await new Promise(r=>setTimeout(r, wait));
      }
    }
  }
  throw lastErr || new Error('No proxy succeeded');
}

// parse tokens from HTML safely
function parseTokensFromHtml(html, selector){
  try{
    const tokensRegex = html.match(/\b(B|P|T|Banker|Player|Tie|Banqueiro|Jogador|Empate)\b/gi);
    if(tokensRegex && tokensRegex.length) return tokensRegex.map(t=> normalizeToken(t)).filter(Boolean);
    if(selector){
      try{
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const nodes = doc.querySelectorAll(selector);
        if(nodes && nodes.length){
          let text = '';
          nodes.forEach(n=> text += ' ' + (n.textContent || ''));
          const parsed = parseSequence(text);
          if(parsed.length) return parsed;
        }
      }catch(e){}
    }
    const simple = html.replace(/[^PBTpbt]/g, '').split('').map(c=>c.toUpperCase()).filter(c=>['P','B','T'].includes(c));
    return simple;
  }catch(e){
    return [];
  }
}

// merge tokens into series safely
function mergeTokens(tokens){
  if(!tokens || tokens.length===0) return 0;
  let added=0;
  tokens.forEach(t=>{
    if(!t) return;
    if(series.length===0 || series[series.length-1] !== t){
      series.push(t); added++;
    }
  });
  if(series.length > 1200) series = series.slice(-1200);
  return added;
}

// analysis engine
function analyzeSeries(arr, opts={windowSize:20, streakBoost:0.06}){
  if(!arr || arr.length===0) return {rec:'—', conf:0, pct:{P:0,B:0,T:0}, streak:0};
  const windowSize = parseInt(opts.windowSize) || 20;
  const streakBoost = parseFloat(opts.streakBoost) || 0.06;
  const norm = arr.slice(-Math.max(windowSize,6) - 200);
  const total = Math.max(1, norm.length);
  const counts = {P:0,B:0,T:0}; norm.forEach(v=> counts[v] ? counts[v]++ : counts[v]=1);
  const pct = {P: counts.P/total || 0, B: counts.B/total || 0, T: counts.T/total || 0};
  const wsize = Math.min(windowSize, norm.length);
  let wcnt = {P:0,B:0,T:0}, wsum=0;
  for(let i=0;i<wsize;i++){
    const v = norm[norm.length - wsize + i];
    const wt = Math.pow(1.12, i); wsum += wt;
    if(v==='P') wcnt.P += wt;
    else if(v==='B') wcnt.B += wt;
    else wcnt.T += wt;
  }
  const wpct = {P: wcnt.P/wsum || 0, B: wcnt.B/wsum || 0, T: wcnt.T/wsum || 0};
  let last = norm[norm.length-1], streak=0;
  for(let i=norm.length-1;i>=0;i--){ if(norm[i]===last) streak++; else break; }
  const trans = {P:{P:0,B:0,T:0}, B:{P:0,B:0,T:0}, T:{P:0,B:0,T:0}};
  const transWindow = Math.min(120, norm.length-1);
  for(let i=Math.max(0, norm.length - transWindow -1); i < norm.length -1; i++){
    if(i<0) continue;
    const a=norm[i], b=norm[i+1]; trans[a][b] = (trans[a][b]||0) + 1;
  }
  const transProb = {};
  ['P','B','T'].forEach(k=>{
    const s = trans[k].P + trans[k].B + trans[k].T || 1;
    transProb[k] = {P: trans[k].P/s, B: trans[k].B/s, T: trans[k].T/s};
  });
  const lastState = norm[norm.length-1];
  const markov = transProb[lastState] || {P:1/3,B:1/3,T:1/3};
  let blend = {
    P: markov.P*0.70 + wpct.P*0.22 + pct.P*0.08,
    B: markov.B*0.70 + wpct.B*0.22 + pct.B*0.08,
    T: markov.T*0.70 + wpct.T*0.22 + pct.T*0.08
  };
  if(pct.T < 0.06) blend.T *= 0.55;
  if(streak >= 2) blend[last] += (streakBoost + Math.min(0.12, streak*0.02));
  const sum = blend.P + blend.B + blend.T || 1;
  blend.P /= sum; blend.B /= sum; blend.T /= sum;
  const entries = Object.entries(blend).sort((a,b)=>b[1]-a[1]);
  const rec = entries[0][0];
  const baseConf = Math.round(entries[0][1]*100);
  const agreement = ((wpct[rec]||0) + (pct[rec]||0))/2;
  let conf = Math.min(99, baseConf + Math.round(agreement * 16));
  if(streak >= 4) conf = Math.min(99, conf + 4 + streak);
  conf = Math.max(conf, 12);
  return {rec, conf, pct:{P:Math.round(pct.P*100), B:Math.round(pct.B*100), T:Math.round(pct.T*100)}, streak};
}

// render helpers
function renderRecommendation(out){
  const recEl = $('rec');
  const confEl = $('conf');
  const label = out.rec === 'P' ? 'JOGADOR' : out.rec === 'B' ? 'BANQUEIRO' : out.rec === 'T' ? 'EMPATE' : '—';
  recEl.textContent = label;
  confEl.textContent = 'Confiança: ' + (out.conf || 0) + '%';
  if(out.conf >= 88){ recEl.style.background = 'linear-gradient(90deg,var(--accent), #fff6c9)'; recEl.style.color = '#072206'; }
  else if(out.rec === 'P'){ recEl.style.background = 'var(--player)'; recEl.style.color = '#072238'; }
  else if(out.rec === 'B'){ recEl.style.background = 'var(--banker)'; recEl.style.color = '#210606'; }
  else if(out.rec === 'T'){ recEl.style.background = 'var(--tie)'; recEl.style.color = '#072206'; }
  else { recEl.style.background = '#ccc'; recEl.style.color = '#071018'; }
}
function renderDots(){ const el = $('dots'); el.innerHTML=''; const last = series.slice(-48); last.forEach(v=>{ const d=document.createElement('div'); d.className='dot'; d.style.background = v==='P' ? 'var(--player)': v==='B' ? 'var(--banker)': 'var(--tie)'; el.appendChild(d); }); }
function renderStats(pct){ $('pctP').textContent = pct.P + '%'; $('pctB').textContent = pct.B + '%'; $('pctT').textContent = pct.T + '%'; }

// watchdog
function startWatchdog(timeoutMs=25000){ if(watchdogTimer) clearTimeout(watchdogTimer); watchdogTimer = setTimeout(()=>{ const delta = Date.now() - lastTickTs; if(delta > timeoutMs && monitorRunning){ console.warn('Watchdog triggered'); stopMonitorSafe(); setStatus('Monitor parado (watchdog)'); } }, timeoutMs + 1000); }
function clearWatchdog(){ if(watchdogTimer){ clearTimeout(watchdogTimer); watchdogTimer=null; } }

// main tick robust
async function tickRobust(force=false){
  lastTickTs = Date.now();
  startWatchdog();
  const link = $('linkInput').value.trim();
  const proxy = $('proxyInput').value.trim();
  const selector = $('selectorInput').value.trim();
  if(!link){ setStatus('Sem link — use modo manual'); clearWatchdog(); return; }
  try{
    const res = await fetchBest(link, proxy);
    const html = res.text || '';
    const used = res.used || '(direct)';
    const snapshot = html.slice(0,2000);
    lastFetchedSnapshot = snapshot;
    const tokens = parseTokensFromHtml(html, selector);
    if(!tokens || tokens.length===0){ setStatus('Nenhum token detectado — tente selector ou cole manual'); clearWatchdog(); return; }
    const added = mergeTokens(tokens);
    const out = analyzeSeries(series, {windowSize: Number(document.getElementById('windowSize')?.value||20), streakBoost: Number(document.getElementById('streakSens')?.value||0.06)});
    renderRecommendation(out); renderDots(); renderStats(out.pct);
    setStatus('Lido via ' + used + ' — novos tokens: ' + added + ' — total ' + series.length);
    backoffAttempts = 0;
  }catch(err){
    console.warn('tickRobust error', err);
    backoffAttempts = Math.min(6, backoffAttempts + 1);
    const wait = BACKOFF_BASE * Math.pow(2, backoffAttempts);
    setStatus('Erro fetch/parse: ' + (err.message || err) + ' — backoff ' + wait + 'ms');
  }finally{
    clearWatchdog();
  }
}

// safe start/stop
function startMonitorSafe(){
  if(monitorRunning) return;
  monitorRunning = true;
  if(monitorTimer){ clearInterval(monitorTimer); monitorTimer=null; }
  const iv = Math.max(250, parseInt($('intervalSelect').value || 1000));
  tickRobust(true);
  monitorTimer = setInterval(()=>{
    const delta = Date.now() - lastTickTs;
    if(delta < (iv * 0.6)){ console.debug('Skipping tick to avoid overlap'); return; }
    tickRobust(false);
  }, iv);
  $('startBtn').disabled = true; $('stopBtn').disabled = false;
  setStatus('Monitor iniciado — intervalo ' + iv + 'ms');
}

function stopMonitorSafe(){
  if(!monitorRunning && !monitorTimer) return;
  monitorRunning = false;
  if(monitorTimer){ clearInterval(monitorTimer); monitorTimer = null; }
  clearWatchdog();
  $('startBtn').disabled = false; $('stopBtn').disabled = true;
  setStatus('Monitor parado.');
}

// manual analyze
function analyzeManual(){
  const txt = $('manualInput').value.trim();
  const parsed = parseSequence(txt);
  if(parsed.length===0){ setStatus('Sequência manual inválida'); return; }
  series = parsed.slice(-1200);
  const out = analyzeSeries(series, {windowSize: Number(document.getElementById('windowSize')?.value||20), streakBoost: Number(document.getElementById('streakSens')?.value||0.06)});
  renderRecommendation(out); renderDots(); renderStats(out.pct);
  setStatus('Análise manual completa — ' + series.length + ' tokens.');
}

// UI events
document.getElementById('startBtn').addEventListener('click', startMonitorSafe);
document.getElementById('stopBtn').addEventListener('click', stopMonitorSafe);
document.getElementById('analyzeManualBtn').addEventListener('click', analyzeManual);
document.getElementById('appendBtn').addEventListener('click', ()=>{
  const v = prompt('Insira token (P/B/T):') || '';
  const t = v.trim().toUpperCase().replace(/[^PBT]/g,'');
  if(!t) return alert('Token inválido');
  series.push(t);
  if(series.length>1200) series = series.slice(-1200);
  const cur = $('manualInput').value.trim();
  $('manualInput').value = (cur ? (cur + ',' + t) : t);
  analyzeManual();
});
document.getElementById('clearBtn').addEventListener('click', ()=>{ series=[]; $('manualInput').value=''; renderDots(); renderStats({P:0,B:0,T:0}); $('rec').textContent='—'; $('conf').textContent='Confiança: —'; setStatus('Dados limpos.'); });
document.getElementById('forceBtn').addEventListener('click', ()=>{ document.getElementById('forceBtn').dataset.forceReprocess = (document.getElementById('forceBtn').dataset.forceReprocess === '1') ? '' : '1'; document.getElementById('forceBtn').textContent = document.getElementById('forceBtn').dataset.forceReprocess === '1' ? 'Forçar: ON' : 'Forçar Reprocessamento'; });

// init UI controls for windowSize/streakSens if missing
(function initUI(){
  if(!document.getElementById('windowSize')){
    const el = document.createElement('select'); el.id='windowSize'; el.innerHTML = '<option value=\"10\">10</option><option value=\"20\" selected>20</option><option value=\"40\">40</option><option value=\"100\">100</option>'; el.style.marginTop='10px'; document.querySelector('.panel').insertBefore(el, document.querySelector('.panel').children[document.querySelector('.panel').children.length-1]);
  }
  if(!document.getElementById('streakSens')){
    const el = document.createElement('select'); el.id='streakSens'; el.innerHTML = '<option value=\"0.04\">Baixa</option><option value=\"0.06\" selected>Média</option><option value=\"0.10\">Alta</option>'; el.style.marginTop='10px'; document.querySelector('.panel').insertBefore(el, document.querySelector('.panel').children[document.querySelector('.panel').children.length-1]);
  }
  // seed small sample
  $('manualInput').value = 'P,B,P,P,B,P,B,P,P,B';
  analyzeManual();
})();

</script>
</body>
</html>
